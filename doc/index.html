<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset='utf-8'>
    <title>
      Web API For Accessing Secure Element
    </title>
    <link href="https://www.globalplatform.org/favicon.ico" rel="icon" type=
    "image/x-icon">
    <script src='https://www.w3.org/Tools/respec/respec-w3c-common' async=""
    class='remove'>
</script>
    <script class='remove'>
/*Respec configuration*/
    var 
    yearStart = "2015",
    yearNow = "" + new Date().getFullYear(),
    copyrightYears = (yearStart === yearNow) ? yearStart : yearStart + '-' + yearNow,
    respecConfig = {

          // specification status (e.g. WD, LCWD, NOTE, etc.). If in doubt use ED.
          specStatus:           "base",

          // GlobalPlatform Logo
          logos: [
             {
                src: 'https://www.globalplatform.org/images/gplogo_2010.gif',
                href: "https://www.globalplatform.org",
                alt: "GlobalPlatform Logo",
                width: 344,
                height: 49,
                id: 'gp-logo'
             }
          ],
          
          otherLinks: [{
              key: "Related links",
              data: [{
                value: "GlobalPlatform",
                href: "https://www.globalplatform.org"
           }, {
                value: "Github project",
                href: "https://github.com/GlobalPlatform/WebApis-for-SE"
           }] }],
           
          // if your specification has a subtitle that goes below the main
          // formal title, define it here
          // subtitle   :  "an excellent document",

          // if you wish the publication date to be other than the last modification, set this
          // publishDate:  "2009-08-06",

          // if the specification's copyright date is a range of years, specify
          // the start date here:
          copyrightStart: yearStart,

          overrideCopyright: "<p class='copyright'>Copyright © " + copyrightYears + " <a href='https://www.globalplatform.org/'>GlobalPlatform</a>. This document is licensed under the <a class='subfoot' href='https://www.apache.org/licenses/LICENSE-2.0' rel='license'>Apache License, Version 2.0</a></p>",

          // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
          // and its maturity status
          // previousPublishDate:  "1977-03-15",
          // previousMaturity:  "WD",

          // if there a publicly available Editor's Draft, this is the link
          edDraftURI:           "https://globalplatform.github.io/WebApis-for-SE/doc/",
          prevRecURI:           "https://globalplatform.github.io/WebApis-for-SE/doc/public-review.html",

          // if this is a LCWD, uncomment and set the end of its review period
          // lcEnd: "2009-08-05",

          // editors, add as many as you like
          // only "name" is required
          editors:  [
              {
                  name:       "Olivier Potonniée"
              ,   company:    "Gemalto"
              ,   companyURL: "https://www.gemalto.com/"
              },
              {
                  name:       "Ming Yin"
              ,   company:    "Deutsche Telekom"
              ,   companyURL: "https://www.telekom.com/"
              },
          ],
          
          // name of the WG
          wg:           "",

          // URI of the public WG page
          wgURI:        "",

          // name of the public mailing to which comments are due
          wgPublicList: "",

          localBiblio:  {
            "dummy" : "dummy"
            // Reference to the ECMAScript, edition 6, specification
            , "ES6": {
                    title: "ECMA-262, 6th Edition / Draft January 20, 2014"
                ,   href: "http://ecma-international.org/ecma-262/6.0/index.html"
                ,   status: "Draft"
                ,   publisher: "Ecma International"
            }
            , "ETSI-102216": {
                    title:    "TR 102 216 : Smart cards; Vocabulary for Smart Card Platform specifications"
                ,   href:     "https://webapp.etsi.org/workprogram/Report_WorkItem.asp?WKI_ID=18815&curItemNr=1&totalNrItems=1&optDisplay=10&qSORT=HIGHVERSION&qETSI_STANDARD_TYPE=%27TR%27&qETSI_NUMBER=102+216"
                ,   authors:  [ "ETSI" ]
                ,   publisher:  "ETSI"
              }
            , "ISO7816-3": {
                    title:    "7816-3 Identification cards -- Integrated circuit cards -- Part 3: Cards with contacts -- Electrical interface and transmission protocols"
                ,   href:     "http://www.iso.org/iso/fr/home/store/catalogue_tc/catalogue_detail.htm?csnumber=38770"
                ,   authors:  [ "ISO/IEC" ]
                ,   publisher:  "ISO"
              }
            , "ISO7816-4": {
                    title:    "7816-4 Identification cards -- Integrated circuit cards -- Part 4: Organization, security and commands for interchange"
                ,   href:     "http://www.iso.org/iso/home/store/catalogue_tc/catalogue_detail.htm?csnumber=54550"
                ,   authors:  [ "ISO/IEC" ]
                ,   publisher:  "ISO"
              }
            , "ISO7816-5": {
                    title:    "7816-5 Identification cards -- Integrated circuit cards -- Part 5: Registration of application providers"
                ,   href:     "http://www.iso.org/iso/home/store/catalogue_tc/catalogue_detail.htm?csnumber=34259"
                ,   authors:  [ "ISO/IEC" ]
                ,   publisher:  "ISO"
              }
            , "WEBCRYPTO": {
                    title:    "Web Cryptography API"
                ,   href:     "https://www.w3.org/TR/WebCryptoAPI/"
                ,   authors:  [ "W3C Web Cryptography Working Group" ]
                ,   publisher:  "W3C"
              }
            , "NFC": {
                    title:    "Web NFC"
                ,   href:     "https://www.w3.org/community/web-nfc/"
                ,   authors:  [ "W3C Near Field Communications (NFC) Community Group" ]
                ,   publisher:  "W3C"
              }
            , "GP": {
                    title:    "Card specifications"
                ,   authors:  [ "GlobalPlatform" ]
                ,   href:     "https://www.globalplatform.org/specificationscard.asp"
                ,   publisher:  "GlobalPlatform"
              }
            , "GP-AC": {
                    title:    "Secure Element Access Control"
                ,   authors:  [ "GlobalPlatform" ]
                ,   href:     "https://www.globalplatform.org/specificationsdevice.asp"
                ,   publisher:  "GlobalPlatform"
              }
          }
      };
    </script>
    <script class='remove'>
window.onload = function () { 
    require(["core/pubsubhub"], function (respecEvents) {
        "use strict";
        respecEvents.sub("end-all", function () {
          var title = document.querySelector("h2");
          if (title) title.innerHTML = "GlobalPlatform Device Specification";
          var statusIntro = document.querySelector("#sotd > p:nth-child(2)");
          if (statusIntro) statusIntro.remove();
          var prev = document.querySelector("#respecHeader > dl:nth-child(6) > dt:nth-child(3)");
          if (prev) prev.innerHTML = "Draft under GlobalPlatform Public Review";
        });
    });
    };
    </script>
    <style>
#gp-logo > img {
    margin-left: -20px;
    }
    </style>
  </head>
  <body>
    <!-- - - - - - - - - - - - - - - Abstract - - - - - - - - - - - - - - - -->
    <section id="abstract">
      <p>
        A Secure Element is a tamper proof device, providing a secure storage
        and execution environment for sensitive data and processing. It offers
        both physical and logical protection against attacks, ensuring
        integrity and confidentiality of its content. Trusted Execution
        Environment (TEE) is out of scope of this specification.
      </p>
      <p>
        This specification defines a communication interface between a web
        application and a Secure Element. It makes no assumption on the Secure
        Element type, application domain or physical communication media.
      </p>
    </section>
    <!-- - - - - - - - - - -  Status of this document - - - - - - - - - - - -->
    <section id="sotd">
      <p>
        <strong>This is a work-in-progress specification. Implementers are
        informed that this API may change without providing any backward
        compatibility at this stage.</strong> If you are interested in
        implementing or using this API, we encourage you to contact the
        editors.
      </p>
      <p>
        See <a href="#Changes">Changes section</a> for history details.
      </p>
    </section>
    <!-- - - - - - - - - - - - - -  Introduction  - - - - - - - - - - - - - -->
    <section class="informative">
      <h2>
        Introduction
      </h2>
      <p>
        The API defined herein allows applications to interact with Secure
        Elements. Considered Secure Elements are those complying to
        [[!ISO7816-4]], which defines a command/response protocol, based on
        structured <abbr title="Application Protocol Data Unit">APDU</abbr>
        (Application Protocol Data Unit).
      </p>
      <!-- - - - - - - - - - - -  Technical Background  - - - - - - - - - - - -->
      <section>
        <h2>
          Technical Background
        </h2>
        <p>
          Secure Elements addressed by this specification are microcontrollers
          that may come in different form factors, such as:
        </p>
        <ul>
          <li>Smart cards. The chip is embedded in a plastic card usually of
          the size of a typical credit card. The card may show physical
          contacts to communicate with the chip, or the chip may support
          <abbr title="Near Field Communication">NFC</abbr> (Near Field
          Communication), in which case the plastic card embeds an antenna.
          Some cards also support both communication methods.
          </li>
          <li>
            <a><abbr title="Universal Integrated Circuit Card">UICC</abbr></a>
            (Universal Integrated Circuit Card) are smart cards used in
            cellular telephony, which may be delivered in different sizes. They
            are often called <abbr title=
            "Subscriber Identity Module">SIM</abbr>, which is actually the name
            of the application hosted by the <a>UICC</a> to access GSM
            networks. <a>UICC</a> may however host other applications.
          </li>
          <li>Smart <abbr title="Storage Device">SD</abbr> cards have a similar
          form as usual SD cards, but internally include a Secure Element and
          support an extended set of SD commands to communicate with the Secure
          Element. Some of these smart SD cards also support NFC.
          </li>
          <li>Embedded Secure Elements, which are chips directly bonded on the
          device mother board. Unlike other form factors, this one does not
          allow interchanging or extracting the Secure Element, it is
          permanently attached to the device.
          </li>
        </ul>
        <p>
          Similarly to a computer, a Secure Element may host one or multiple
          applications. Typical applications are mobile network authentication
          (SIM cards), payment (credit cards), authentication and signature
          (corporate badges, eID, etc.), loyalty, ticketing (public
          transports). These are only examples; many other applications have
          been and can be deployed.
        </p>
        <p>
          Applications hosted by the Secure Elements are called
          <dfn>on-card</dfn> applications. On-card applications have a limited,
          if any, user interface. An application can be useful with an off-card
          application part, which handles the dialog with the user or with
          external computing resources. Examples of <dfn>off-card</dfn>
          applications are <abbr title="Automatic Toll Machines">ATM</abbr> for
          payment, mail applications for signature, access control doors for
          authentication, etc. This specification defines the API to be used by
          off-card applications based on web technologies.
        </p>
      </section><!-- Technical Background -->
      <!-- - - - - - - - - - - - Use Cases - - - - - - - - - - - -->
      <section>
        <h2>
          Use Cases
        </h2>
        <p>
          This specification shows how to develop web applications making use
          of these Secure Element applications. Some typical use cases that
          applications can address based on this API include:
        </p>
        <ul>
          <li>
            <strong>Authentication:</strong> Instead of user name and password,
            access to an online service may be protected by a strong
            authentication mechanism, based on credentials stored and processed
            in a Secure Element. In web-based operating systems, system
            applications such as <abbr title=
            "Virtual Private Network">VPN</abbr> (Virtual Private Network) or
            eMail application may use of the Secure Element to authenticate the
            user.
          </li>
          <li>
            <strong>Digital Signature:</strong> Applications may use the Secure
            Element to digitally sign a document or any data with a key stored
            in this Secure Element. The signature operation itself is executed
            inside the Secure Element, ensuring both the integrity of the
            signature and the confidentiality of the key used in this process.
            For instance, this could be used by an eMail application to sign
            emails sent by the user. Or by a government web application to sign
            a online administrative request.
          </li>
          <li>
            <strong>Payment:</strong> Online commerce may use widely used smart
            credit cards or specific payment applications, to enforce the
            security of online transactions. In cellular telephony environment,
            the on-card payment application may be hosted on the UICC,
            alleviating the need for the user to handle multiple physical
            devices.
          </li>
          <li>
            <strong>Credential provisioning:</strong> The content of a Secure
            Element may be updated to install, update or remove an application
            or any credential it may host. For example, a public transport
            application may offer users to credit their NFC-enabled transport
            card with tickets bought online. In another example, a corporate
            intranet web application may enable employees to renew online the
            X.509 certificates hosted in their corporate badge from anywhere
            just before the certificates expire.
          </li>
        </ul>
        <p>
          Whatever the form factor listed above, Secure Element considered in
          this specification implements the same [[!ISO7816-4]] transport
          protocol. The physical media (USB, NFC or any other wired or wireless
          technique) used in this communication is abstracted by the API
          defined in this specification.
        </p>
      </section><!-- Use Cases -->
      <!-- - - - - - - - - - - - - -  Relationship to W3C APIs - - - - - - - - - - - - - -->
      <section>
        <h2>
          Relationship to W3C APIs
        </h2>
        <p>
          This specification, although addressing some concepts similar to
          several W3C specifications, has distinct use cases and offer
          different level of services:
        </p>
        <ul>
          <li>The current NFC API draft specification [[NFC]] defines an API
          allowing to exchange NDEF messages with NFC tags or peers. While the
          Secure Element API specified herein allows web applications to send
          commands to Secure Elements wired or plugged in the device or
          wirelessly connected to the device thanks to NFC technology. The
          difference between the different communication links (wired or NFC)
          is only visible through Secure Element type in this API, but does not
          impact the way applications would interact with the Secure Element.
          As such there is no overlap of functionalities between the two APIs.
          </li>
          <li>The Web Cryptography API draft specification [[WEBCRYPTO]]
          defines an API allowing a web application to invoke cryptographic
          services. Its implementation is independent from the underlying
          layers performing the actual cryptographic operations: it might be
          pure software or use a dedicated hardware such as a Secure Element or
          a TPM. As such there is not overlap between the two APIs.
          Nevertheless one can imagine that a Web Cryptography API
          implementation may use the Secure Element API directly, but this will
          be implementation dependent.
          </li>
        </ul>
      </section><!-- Relationship to W3C APIs -->
    </section><!-- Introduction -->
    <!-- - - - - - - - - - - - - - Conformance  - - - - - - - - - - - - - - -->
    <section id="conformance">
      <p>
        This specification defines conformance criteria that apply to a single
        product: the <dfn>user agent</dfn> that implements the interfaces that
        it contains.
      </p>
      <p>
        Implementations that use ECMAScript to implement the APIs defined in
        this specification MUST implement them in a manner consistent with the
        ECMAScript Bindings defined in the Web IDL specification [[!WEBIDL]],
        as this specification uses that specification and terminology.
      </p>
    </section><!-- Conformance -->
    <!-- - - - - - - - - - - - - -  Dependencies  - - - - - - - - - - - - - -->
    <section>
      <h2>
        Dependencies
      </h2>
      <p>
        This specification depends on interfaces and concepts defined in the
        following specifications.
      </p>
      <p>
        [[!HTML]]: <dfn><a href=
        "https://www.whatwg.org/specs/web-apps/current-work/#event-handlers">event
        handler</a></dfn>.
      </p>
      <p>
        [[!DOM4]]: the <dfn><a href=
        "https://dom.spec.whatwg.org/#event"><code>Event</code></a></dfn> and
        <dfn><a href=
        "https://dom.spec.whatwg.org/#domexception"><code>DOMException</code></a></dfn>
        interfaces, the concept of <dfn><a href=
        "https://dom.spec.whatwg.org/#concept-event-fire">firing an
        event</a></dfn>.
      </p>
      <p>
        [[!ES6]]: the <dfn><a href=
        "http://ecma-international.org/ecma-262/6.0/index.html#sec-promise-objects">
        <code>Promise</code></a></dfn> object type.
      </p>
      <p>
        [[!RFC6454]]: The concepts of <dfn>origin</dfn> and
        <dfn>same-origin</dfn>, as well as the algorithm for serializing an
        origin.
      </p>
      <p>
        [[!GP-AC]]: The <dfn>Access Rules</dfn> and <dfn>Access Control
        Enforcer</dfn> (<abbr title="Access Control Enforcer">ACE</abbr>)
        concepts.
      </p>
      <p>
        [[!GP]]: The <dfn>Supplementary Logical Channel</dfn> concept.
      </p>
      <p>
        Some Secure Element concepts are defined in ISO/IEC specifications:
      </p>
      <ul>
        <li>
          <dfn>APDU command</dfn>, <dfn>APDU response</dfn>, <dfn>class
          byte</dfn>, <dfn>instruction byte</dfn>, <dfn>parameter bytes</dfn>,
          <dfn>data field bytes</dfn>, <dfn>status word</dfn>, <dfn>extended
          length</dfn>, <dfn>logical channel</dfn>, <dfn>basic logical
          channel</dfn> and <dfn>historical bytes</dfn> are defined in
          [[!ISO7816-4]]
        </li>
        <li>
          <dfn><abbr title="Application Identifier">AID</abbr></dfn>
          (Application Identifier) is defined in [[!ISO7816-5]].
        </li>
        <li>
          <dfn>UICC</dfn> is defined in [[!ETSI-102216]]
        </li>
      </ul>
    </section><!-- Dependencies -->
    <!-- - - - - - - - - - - - - - Security  - - - - - - - - - - - - - - - - -->
    <section class="informative">
      <h2>
        Security and Privacy Considerations
      </h2>
      <p>
        Using a Secure Element may bring additional security to a web
        application, but is not sufficient to ensure the application is secure.
        In particular, developers using the Secure Element API should be aware
        of the following security considerations:
      </p>
      <ul>
        <li>
          <strong>Communication</strong> between the Secure Element and the web
          application has to be secured in order to ensure the confidentiality
          and integrity of the message exchange. This can either be achieved if
          the web application using the Secure Element API executes in a
          trusted execution environment offering guarantees on the integrity
          and confidentiality of the communication link. Or it can be provided
          programmatically by encryption and/or MACing of the messages
          exchanged with the Secure Element (e.g. using GlobalPlatform's secure
          messaging technology [[GP]]). The off-card processing of these
          messages has then to be done in a trusted execution environment,
          which may be on the device to which the Secure Element is connected,
          or on a remote device (e.g. the web application's originating
          server).
        </li>
        <li>
          <strong>Interface</strong> between the user and the web application
          typically consists of displayed text and images (e.g. a transaction
          confirmation dialog) and user inputs (e.g. a PIN code). Protecting
          this interface is out of the scope of this specification. If the
          application requires such guarantee, it should restrict its execution
          on Trusted Execution Environments.
        </li>
        <li>
          <strong>Access</strong> to <a>on-card</a> applications should be
          restricted to authorized parties. On-card applications usually
          enforce such control by requiring authentication of the off-card
          communicating party, for instance by asking user to present a PIN to
          unlock access or performing a mutual authentication before any
          sensitive operation.<br>
          There is however a risk of denial of service (DoS) attacks, where an
          attacker could e.g. either deliberately present multiple invalid PIN
          values to block the Secure Element or sending burst of commands
          preventing legitimate applications to execute optimally. In order to
          mitigate this risk, this specification requires the web application
          runtime to implement the access control mechanism defined in <a href=
          "#access-control">Access Control</a> section.
        </li>
        <li>
          <strong>Traceability</strong> of the user may be facilitated by the
          unique identifying information the Secure Element may contain. Here
          again, the access control defined in <a href="#access-control">Access
          Control</a> section will ensure only authorized web applications have
          access to the Secure Element API.
        </li>
      </ul>
    </section><!-- Security -->
    <!-- - - - - - - - - - - - - -  Secure Element Services  - - - - - - - - - - -->
    <section class="informative">
      <h2>
        Secure Element Services
      </h2>
      <p>
        Communication with a Secure Element is performed through a
        <dfn>reader</dfn>, which unlike its name suggests it not only able to
        read content from Secure Element, but also to write or send any
        application specific command. Given the removal nature of many Secure
        Elements, a reader may be empty, meaning that no Secure Element is
        connected to this reader. For instance, a USB smart card reader may be
        connected to a computer but no smart card is inserted or a device may
        support NFC interactions with Secure Elements but none is in the field.
        For this reason, the API provides a means to query the list of
        available readers and for each of them if they are empty or if a Secure
        Element is present. In addition, this specification defines events that
        are triggered when a Secure Element is connected to a reader and also
        when it is disconnected.
      </p>
      <p>
        Once a web application is informed that a reader has a connected Secure
        Element, it can open a <dfn>session</dfn> with it. Opening a session
        establishes the communication between the web application and the
        Secure Element and provides a session object to the application.
        However a Secure Element is just an application container, the web
        application still needs to identify the application with which it wants
        to communicate.
      </p>
      <p>
        To this intent, the session object provides a means to open a
        <dfn>channel</dfn> with a specific <a>on-card</a> application, which is
        uniquely identified by an <a>AID</a>. The web application runtime and
        the Secure Element may then perform some internal security checking to
        ensure the web application is allowed to connect to this <a>on-card</a>
        application. If authorized, the returned channel object is the one
        providing the method to send commands to the <a>on-card</a> application
        and get the corresponding responses.
      </p>
      <p>
        The above steps required to send a command to a Secure Element create a
        set of chained objects. A reader may have several opened sessions,
        which may have several opened channels. Each object has a
        <code>close()</code> method to release all resources associated to the
        target object, which invokes the <code>close()</code> method on each
        underlying object in the chain.
      </p>
      <figure>
        <a href="#class-graph"><img src="images/class-graph.png" alt=
        "Class graph"></a>
        <figcaption id="class-graph">
          The figure above represents the class relationships between the
          Secure Element entities introduced in this specification.
        </figcaption>
      </figure>
    </section><!-- Secure Element Services -->
    <!-- - - - - - - - - - - - - -  Access Control  - - - - - - - - - - -->
    <section id="access-control">
      <h2>
        Access Control
      </h2>
      <p>
        In order to make sure only authorized web applications can access the
        Secure Element, the web application runtime MUST use the access control
        defined in [[GP-AC]], which defines a simple mechanism that protects
        legitimate users using non-compromised devices from malicious
        applications. Note that it does not protect from a compromised device
        that would not properly implement the Access Control Enforcer, which is
        addressed by the internal protection of the Secure Element itself
        (using e.g. PIN or secure messaging). The interface between the web
        application runtime and the Access Control Enforcer is out of scope of
        this specification.
      </p>
      <section>
        <h3>
          Overall Architecture
        </h3>
        <p>
          To control which applications running on a user device are allowed to
          access <a>on-card</a> applications, several entities are involved:
        </p>
        <ul>
          <li>The Secure Element hosts a list of <a>Access Rules</a>. An access
          rule contains the <a>AID</a> of the <a>on-card</a> application, the
          identifier of the requesting <a>off-card</a> application and a filter
          on authorized APDUs. The access rule may also contain a simple
          Boolean to authorize all or no communications.
          </li>
          <li>An <a>Access Control Enforcer</a> is running on the same device
          as the <a>off-card</a> application. Any attempt to establish a
          communication with an <a>on-card</a> application from this device
          triggers this enforcer, which queries the Secure Element to get the
          access rules (and usually cache them) and check that the requesting
          <a>off-card</a> application is authorized to communicate with the
          targeted <a>on-card</a> application.
          </li>
        </ul>
        <figure>
          <a href="#access-control-img"><img src="images/gp-access-control.png"
          alt="Class graph"></a>
          <figcaption id="access-control-img">
            The figure above shows the overall access control architecture.
          </figcaption>
        </figure>
        <p>
          Sections below describe how the GlobalPlatform Access Control is
          applied to web applications. Details of the GlobalPlatform Access
          Control mechanisms itself are defined in [[!GP-AC]].
        </p>
      </section>
      <section>
        <h3>
          Client Application Identifier
        </h3>
        <p>
          The <a>Access Control Enforcer</a> uses an application identifier to
          check whether the <a>off-card</a> application is white listed in
          <a>Access Rules</a>. The web application runtime computes the
          application identifier using the following algorithm:
        </p>
        <ul>
          <li>let <code>origin</code> be the ASCII serialization of the web
          application origin as defined in [[!RFC6454]]
          </li>
          <li>set the application identifier to be the SHA-1 digest of this
          <code>origin</code> value.
            <div class="note">
              The SHA-1 hash function is used here because the GlobalPlatform
              Access Control specification for now only supports 20 bytes long
              identifiers. A stronger algorithm will be used as soon as
              GlobalPlatform updates its specification to support longer
              values.
            </div>
          </li>
        </ul>
        <p>
          All applications that have the same <a>origin</a> will get the same
          application identifier, hence use the same <a>Access Rules</a>.
        </p>
        <p>
          While applying the GlobalPlatform Access Control process, if the
          <a>Access Control Enforcer</a> detects that the Secure Element does
          not implement the GlobalPlatform Access Control (it does not have
          access rules), the <a>Access Control Enforcer</a> may use its own
          policy to grant or refuse access to the Secure Element API.
        </p>
      </section>
      <section>
        <h3>
          Additional Security Rules
        </h3>
        <p>
          To be eligible to gain access to the Secure Element API, a web
          application must meet the following requirements:
        </p>
        <ul>
          <li>The web application MUST be fetched using HTTPS protocol.
          </li>
          <li>The TLS/SSL server certificate of this HTTPS connection MUST be
          trusted and valid:
            <ul>
              <li>Its subject MUST match the hosting domain name.
              </li>
              <li>Its validity dates MUST include the current date provided by
              the execution runtime.
              </li>
              <li>The issuance signature chain MUST be valid.
              </li>
              <li>The issuance chain MUST be rooted by a CA trusted by the web
              application runtime.
              </li>
            </ul>
          </li>
          <li>The user MUST NOT be able to bypass these rules. Some browsers
          offer users to define "exceptions" to allow connections to a HTTPS
          URL even if SSL server certificate is invalid. Such exception MUST
          NOT be used to allow access to the Secure Element API.
          </li>
        </ul>
      </section>
    </section><!-- Access Control -->
    <!-- - - - - - - - - - - - Handling of Status Word - - - - - - - - - -->
    <section>
      <h2>
        General Rules for Handling of Status Word
      </h2>
      <p>
        This specification defines handling of status word as defined in ISO
        7816 specifications, in order to behave correctly with any secure
        element application across different sectors (banking, transport,
        identity, etc.).
      </p>
      <section>
        <h3>
          Using Transport layer T=1
        </h3>
        <p>
          The API or the underlying implementation shall handle the protocol
          T=1 as specified in [[ISO7816-3]] and returns data (if available) and
          received status word to the application. The API or underlying
          implementation shall never automatically issue GET-RESPONSE APDU on
          reception of any status word.
        </p>
      </section>
      <section>
        <h3>
          Using Transport layer T=0
        </h3>
        <p>
          Unless otherwise specified, when sending command APDU, this
          specification requires the following management for status word for
          all the methods defined in this document:
        </p>
        <ul>
          <li>For status word ‘61 XX’ the API or underlying implementation
          shall issue a GET RESPONSE command as specified by ISO 7816 standard
          with LE=XX. The same behaviour has to be applied for the scenario
          where the SE returns overall response data of more than 256 bytes to
          the APDU. If an Error SW is received to GET RESPONSE command, all
          data received so far shall be discarded and the Error SW shall be
          returned.
          </li>
          <li>For the status word ‘6C XX’, the API or underlying
          implementation shall reissue the input command with LE=XX as
          specified by ISO 7816 standard. If an Error SW is received to the
          reissued command, all data received so far shall be discarded and the
          Error SW shall be returned.
          </li>
          <li>For any status words different than 61xx and 6Cxx the API or
          underlying implementation shall not handle the received status words
          internally (e.g.: it shall not send GET RESPONSE automatically). The
          API or underlying implementation shall provide the status word
          together with data, if data is also received with the SW to the
          calling web application.
          </li>
        </ul>
      </section>
      <p>
        Note that the handling of GET RESPONSE specified above implies that the
        API or underlying implementation shall handle response data even if it
        is more than 256 bytes.
      </p>
    </section><!-- Handling of Status Word -->
    <!-- - - - - - - - - - - - Interface Navigator - - - - - - - - - -->
    <section>
      <h2>
        <a>Navigator</a> Interface
      </h2>
      <p>
        The <a>Navigator</a> exposes the Secure Element service.
      </p>
      <pre class="idl">
partial interface Navigator {
    readonly        attribute SecureElementManager? secureElementManager;
};
</pre>
      <section>
        <h3>
          Attributes
        </h3>
        <dl data-link-for="Navigator" data-dfn-for="Navigator" class=
        "attributes">
          <dt>
            <dfn>secureElementManager</dfn> of type <span class=
            "idlAttrType"><a>SecureElementManager</a></span>, readonly,
            nullable
          </dt>
          <dd>
            When getting the <a>secureElementManager</a> attribute, the user
            agent MUST return the <a>SecureElementManager</a> object that
            provides access to available Secure Element readers. If the user
            agent doesn't support Secure Element features, it MUST then return
            <code>undefined</code>.
          </dd>
        </dl>
      </section>
    </section><!-- Interface Navigator -->
    <!-- - - - - - - - - - - - Interface SecureElement - - - - - - - - - -->
    <section>
      <h2>
        <a>SecureElementManager</a> Interface
      </h2>
      <p>
        The <a>SecureElementManager</a> interface provides access to Secure
        Element readers and is the source of events notifying the presence of
        Secure Elements.
      </p>
      <pre class="idl">
interface SecureElementManager : EventTarget {
    attribute EventHandler? onsepresent;
    attribute EventHandler? onseremoval;
    Promise&lt;Reader[]&gt; getReaders ();
    Promise&lt;void&gt;     shutdown ();
};
</pre>
      <section>
        <h3>
          Attributes
        </h3>
        <dl data-link-for="SecureElementManager" data-dfn-for=
        "SecureElementManager" class="attributes">
          <dt>
            <dfn>onsepresent</dfn> of type <span class=
            "idlAttrType"><a>EventHandler</a></span>, nullable
          </dt>
          <dd>
            Event handler for the SE-present event. This event MUST be
            triggered each time any of the following situations occurs:
            <ul>
              <li>Web application starts while a Secure Element is present in a
              reader
              </li>
              <li>Web application is running, a reader which was already listed
              in the readers attribute but had no Secure Element now detects
              the presence of a Secure Element.
              </li>
              <li>Web application is running, a new reader is detected and has
              a Secure Element present.
              </li>
            </ul>The event name is <code>sepresent</code> and event type is
            <a>ReaderEvent</a>.
          </dd>
          <dt>
            <dfn>onseremoval</dfn> of type <span class=
            "idlAttrType"><a>EventHandler</a></span>, nullable
          </dt>
          <dd>
            Event handler for the SE-removal event. This event MUST be
            triggered when a Secure Element which was present in a reader is no
            longer present (Meaning it has been unplugged or is out of reach if
            it was connected through wireless communication). As soon as this
            event is triggered, all <a>Session</a> and <a>Channel</a> objects
            providing access to this Secure Element are marked as closed. The
            event name is <code>seremoval</code> and event type is
            <a>ReaderEvent</a>.
          </dd>
        </dl>
      </section>
      <section>
        <h3>
          Methods
        </h3>
        <dl data-link-for="SecureElementManager" data-dfn-for=
        "SecureElementManager" class="methods">
          <dt>
            <dfn>getReaders</dfn>
          </dt>
          <dd>
            This method MUST return the list of available readers in which a
            Secure Element may be present. Its value MUST be an empty array if
            no reader is available. It MUST be <code>null</code> if the
            <code>shutdown()</code> method has been called on this
            <a>SecureElementManager</a> object. Several invocations of this
            method MAY return different array values, because new readers may
            become available, while others may be disconnected.
          </dd>
          <dt>
            <dfn>shutdown</dfn>
          </dt>
          <dd>
            <p>
              This method closes all sessions and channels opened from this
              <a>SecureElementManager</a> object and releases other potential
              internal resources. When invoked, the user agent MUST run the
              following steps:
            </p>
            <ol>
              <li>Let <var>promise</var> be a newly-created <a>Promise</a>
              object.
              </li>
              <li>Return <var>promise</var> and continue the following steps
              asynchronously.
              </li>
              <li>If the <code>shutdown()</code> method has already been called
              on this object, then resolve <var>promise</var>.
              </li>
              <li>Let <var>countdown</var> be the number of readers in the
              <code>readers</code> attribute and <var>error</var> an object
              initially <code>undefined</code>.
              </li>
              <li>Invoke <code>closeSessions()</code> method on each
              <a>Reader</a> object in the array returned by the
              <code>readers</code> attribute.
              </li>
              <li>Let <var>readerpromises</var> be the set of <a>Promise</a>
              objects returned by these <code>closeSessions()</code>
              invocations.
              </li>
              <li>Set the <code>readers</code> attribute value to
              <code>null</code>.
              </li>
              <li>If <var>countdown</var> is 0, then resolve <var>promise</var>
              with this <a>SecureElementManager</a> object.
              </li>
              <li>When a <var>readerpromises</var> element is fulfilled, <var>
                countdown</var> is decremented. If <var>countdown</var> is 0
                and <var>error</var> is <code>undefined</code>, then resolve
                <var>promise</var>. If <var>countdown</var> is 0 and
                <var>error</var> is not <code>undefined</code>, then reject
                <var>promise</var> with the <var>error</var> value.
              </li>
              <li>When a <var>readerpromises</var> element is rejected,
              <var>countdown</var> is decremented. If <var>error</var> is
              <code>undefined</code> then set it to the rejected value. If
              <var>countdown</var> is 0 then reject <var>promise</var> with
              <var>error</var> value.
              </li>
            </ol>
          </dd>
        </dl>
        <!-- - - - - - - - - - - - Interface SecureElement - - - - - - - - - -->
      </section><!-- - - - - - - - - - - - Events - - - - - - - - - -->
      <section>
        <h3>
          Events
        </h3>
        <p>
          The <code>sepresent</code> and <code>seremoval</code> events are of
          type <a>ReaderEvent</a>.
        </p>
        <pre class="idl">
[Constructor(DOMString type, optional ReaderEventInit eventInitDict), Exposed=Window,Worker]
interface ReaderEvent : Event {
    readonly        attribute Reader reader;
};
</pre>
        <section>
          <h3>
            Attributes
          </h3>
          <dl data-link-for="ReaderEvent" data-dfn-for="ReaderEvent" class=
          "attributes">
            <dt>
              <dfn>ReaderEvent.reader</dfn> of type <span class=
              "idlAttrType"><a>Reader</a></span>, readonly
            </dt>
            <dd>
              The reader on which the Secure Element event occurred
            </dd>
          </dl><!-- ReaderEventInit -->
        </section>
        <section>
          <h3>
            Constructor Parameters
          </h3>
          <pre class="idl">
dictionary ReaderEventInit : EventInit {
  Reader reader;
};
</pre>
          <dl data-link-for="ReaderEventInit" data-dfn-for="ReaderEventInit"
          class="attributes">
            <dt>
              <dfn>ReaderEventInit.reader</dfn> of type <span class=
              "idlAttrType"><a>Reader</a></span>
            </dt>
            <dd>
              The event's reader attribute value
            </dd>
          </dl>
        </section><!-- ReaderEventInit -->
      </section><!-- ReaderEvent -->
    </section><!-- Interface SecureElementManager -->
    <!-- - - - - - - - - - - - Interface Reader - - - - - - - - - -->
    <section>
      <h2>
        <a>Reader</a> Interface
      </h2>
      <p>
        Readers connected to this device are accessible through the
        <a>Reader</a> interface. A reader is the connector to a Secure Element.
        Given the removable nature of some Secure Elements, a reader may or may
        not have a Secure Element present. A reader MUST have at most one
        present Secure Element. A reader MAY for instance be a <a>UICC</a>
        slot, a USB smart card reader, an NFC interface or a mother board slot
        where a embedded Secure Element is wired.
      </p>
      <pre class="idl">
interface Reader {
    readonly        attribute boolean           isSEPresent;
    readonly        attribute DOMString         name;
    readonly        attribute SecureElementType secureElementType;
    readonly        attribute boolean           isRemovable;
    Promise&lt;Session&gt; openSession ();
    Promise&lt;void&gt;    closeSessions ();
    Promise&lt;void&gt;    reset ();
};
</pre>
      <section>
        <h3>
          Attributes
        </h3>
        <dl data-link-for="Reader" data-dfn-for="Reader" class="attributes">
          <dt>
            <dfn>isSEPresent</dfn> of type <span class=
            "idlAttrType"><a>boolean</a></span>, readonly
          </dt>
          <dd>
            This attribute MUST return true if a Secure Element is present in
            this reader. It MUST return false otherwise.
          </dd>
          <dt>
            <dfn>name</dfn> of type <span class=
            "idlAttrType"><a>DOMString</a></span>, readonly
          </dt>
          <dd>
            This attribute MUST return the name of the reader. This is an
            arbitrary name set by the system. It MAY be computed based on
            reader provided data.
          </dd>
          <dt>
            <dfn>secureElementType</dfn> of type <span class=
            "idlAttrType"><a>SecureElementType</a></span>, readonly
          </dt>
          <dd>
            This attribute MUST return the <a>SecureElementType</a> value that
            matches the type of the Secure Element this reader gives access to.
            This information may be useful for applications that target a
            specific Secure Element type. It may also be used to build the
            application user interface, to represent the Secure Element in a
            realistic way.
          </dd>
          <dt>
            <dfn>isRemovable</dfn> of type <span class=
            "idlAttrType"><a>boolean</a></span>, readonly
          </dt>
          <dd>
            This attribute MUST return <code>true</code> if the Secure Element
            cannot be detached without powering down the device.
          </dd>
        </dl>
      </section>
      <section>
        <h3>
          Methods
        </h3>
        <dl data-link-for="Reader" data-dfn-for="Reader" class="methods">
          <dt>
            <dfn>openSession</dfn>
          </dt>
          <dd>
            This method establishes a communication link with a Secure Element.
            There may be several sessions opened at the same time: no session
            shall lock access to the Secure Element.
          </dd>
          <dt>
            <dfn>closeSessions</dfn>
          </dt>
          <dd>
            This method closes all sessions opened through this reader object.
            This also closes their associated channels.
          </dd>
          <dt>
            <dfn>reset</dfn>
          </dt>
          <dd>
            This method resets the physical interface of the Secure Element.
            The enabling process of the physical interface MUST be replayed. If
            the physical interface does not support or allow the operation,
            this method MUST fail with <code>SEUnsupportedException</code>.
            error.
          </dd>
        </dl>
      </section>
      <!-- - - - - - - - - - - - Enum SecureElementType - - - - - - - - - -->
      <section>
        <h3>
          <a>SecureElementType</a> Enum
        </h3>
        <p>
          The <a>SecureElementType</a> enum identifies the type of the Secure
          Element a reader gives access to.
        </p>
        <pre class="idl">
enum SecureElementType {
    "uicc",
    "smartcard",
    "ese",
    "sd",
    "other"
};
</pre>
        <table data-link-for="SecureElementType" data-dfn-for=
        "SecureElementType" class="simple">
          <tbody>
            <tr>
              <th colspan="2">
                Enumeration description
              </th>
            </tr>
            <tr>
              <td>
                <dfn>uicc</dfn>
              </td>
              <td>
                <p>
                  The Secure Element is a <a>UICC</a> used by the device to
                  connect to a mobile network.
                </p>
              </td>
            </tr>
            <tr>
              <td>
                <dfn>smartcard</dfn>
              </td>
              <td>
                <p>
                  The Secure Element is a smart card (contactless, contact or
                  USB token).
                </p>
              </td>
            </tr>
            <tr>
              <td>
                <dfn>ese</dfn>
              </td>
              <td>
                <p>
                  The Secure Element is embedded in the device.
                </p>
              </td>
            </tr>
            <tr>
              <td>
                <dfn>sd</dfn>
              </td>
              <td>
                <p>
                  The Secure Element is a SD card and may be unplugged.
                </p>
              </td>
            </tr>
            <tr>
              <td>
                <dfn>other</dfn>
              </td>
              <td>
                <p>
                  For any other Secure Element type not listed above.
                </p>
              </td>
            </tr>
          </tbody>
        </table>
      </section><!-- Enum SecureElementType -->
    </section><!-- Interface Reader -->
    <!-- - - - - - - - - - - - Interface Session - - - - - - - - - -->
    <section>
      <h2>
        <a>Session</a> Interface
      </h2>
      <p>
        A <a>Session</a> represents a connection to one of the Secure Elements
        available on the device. These objects can be used to open and close
        communication channels with an <a>on-card</a> application.
      </p>
      <pre class="idl">
interface Session {
    readonly        attribute Reader      reader;
    readonly        attribute Uint8Array? historicalBytes;
    Promise&lt;Channel&gt; openBasicChannel (Uint8Array? aid, optional octet p2);
    Promise&lt;Channel&gt; openSupplementaryChannel (Uint8Array? aid, optional octet p2);
    Promise&lt;void&gt;    close ();
};
</pre>
      <section>
        <h3>
          Attributes
        </h3>
        <dl data-link-for="Session" data-dfn-for="Session" class="attributes">
          <dt>
            <dfn>reader</dfn> of type <span class=
            "idlAttrType"><a>Reader</a></span>, readonly
          </dt>
          <dd>
            This attribute MUST return the reader object from which this
            session object was created.
          </dd>
          <dt>
            <dfn>historicalBytes</dfn> of type <span class=
            "idlAttrType"><a>Uint8Array</a></span>, readonly, nullable
          </dt>
          <dd>
            This attribute MUST return the <a>historical bytes</a> provided by
            the physical interface of the Secure Element or <code>null</code>
            if the interface does not provide it.
          </dd>
        </dl>
      </section>
      <section>
        <h3>
          Methods
        </h3>
        <dl data-link-for="Session" data-dfn-for="Session" class="methods">
          <dt>
            <dfn>openBasicChannel</dfn>
          </dt>
          <dd>
            <p>
              This methods opens the <a>basic logical channel</a> and selects
              an <a>on-card</a> application. Once this channel has been opened
              by an <a>off-card</a> application, it is considered to be
              "locked" to other applications: any other call to this method
              MUST fail with <code>SENoChannelException</code> error until this
              <a>basic channel</a> is closed. Some Secure Elements might always
              deny opening a basic channel.
            </p>
            <p>
              If the <code>aid</code> parameter is not null, the underlying
              implementation of this operation MUST send a SELECT command to
              the Secure Element, as defined in [[!ISO7816-4]], with following
              header values:
            </p>
            <ul>
              <li>CLA = ‘0x00’
              </li>
              <li>INS = ‘0xA4’
              </li>
              <li>P1 =‘0x04’ (Select by DF name/application identifier)
              </li>
              <li>P2 = <code>p2</code> parameter if present, ‘0x00’
              otherwise (First or only occurrence).
              </li>
            </ul>
            <p>
              If <code>aid</code> is null, then no SELECT command is sent, the
              channel is opened on the default selected <a>on-card</a>
              application.
            </p>
            <p>
              This method MUST trigger the <a>Access Control Enforcer</a> to
              check the requesting <a>off-card</a> application is authorized to
              open such channel.
            </p>
            <p>
              For the SELECT command the API shall handle received status word
              as defined in <a href=
              "#general-rules-for-handling-of-status-word">section 7</a>,
              except that for T=0 protocol the GET RESPONSE shall also be sent
              in case of SW warning (‘62 XX’ or ‘63 XX’). If the status
              word for the SELECT command indicates that the SE was able to
              open a channel (status word ‘90 00’ or status words
              referencing a warning), the API shall keep the channel open and
              the channel's <code>openResponse</code> attribute shall return
              the status word for the SELECT command together with data, if any
              data is received.
            </p>
            <p>
              Other status words for the SELECT command which indicate that the
              SE was not able to open a channel shall be considered as an error
              and the corresponding channel shall not be opened.
            </p>
            <table class="parameters">
              <tbody>
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    aid
                  </td>
                  <td class="prmType">
                    <code>Uint8Array</code>
                  </td>
                  <td class="prmNullTrue">
                    <span role="img" aria-label="True">&#10004;</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">&#10008;</span>
                  </td>
                  <td class="prmDesc">
                    This parameter value MUST either be:
                    <ul>
                      <li>The complete <a>Application Identifier</a> of the
                      targeted <a>on-card</a> application;
                      </li>
                      <li>A partial <a>Application Identifier</a> matching a
                      set of targeted <a>on-card</a> applications. The
                      application with the first matching AID shall be
                      selected;
                      </li>
                      <li>
                        <code>null</code> if the implicitly selected
                        application on this channel shall be selected.
                      </li>
                    </ul>
                  </td>
                </tr>
                <tr>
                  <td class="prmName">
                    p2
                  </td>
                  <td class="prmType">
                    <code>octet</code>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">&#10008;</span>
                  </td>
                  <td class="prmOptTrue">
                    <span role="img" aria-label="True">&#10004;</span>
                  </td>
                  <td class="prmDesc">
                    The P2 parameter of the SELECT APDU executed for this
                    channel. Except for specific needs, it is recommended to
                    omit this method parameter. If provided, the following
                    values are supported as defined in [[!ISO7816-4]]:
                    ‘00’, ‘04’, ‘08’, ‘0C’.
                  </td>
                </tr>
              </tbody>
            </table>
          </dd>
          <dt>
            <dfn>openSupplementaryChannel</dfn>
          </dt>
          <dd>
            <p>
              This methods opens a <a>supplementary logical channel</a> and
              selects an <a>on-card</a> application. The Secure Element MUST
              open the next available supplementary logical channel. If no more
              supplementary logical channels are available, this method MUST
              fail with <code>SENoChannelException</code> error.
            </p>
            <p>
              If the <code>aid</code> parameter is not null, the underlying
              implementation of this operation MUST send to the Secure Element
              a SELECT command, as defined in [[!ISO7816-4]], with following
              header values:
            </p>
            <ul>
              <li>CLA = ‘0x01’ to ‘0x03’, ‘0x40 to 0x4F’ (as chosen
              by the Secure Element)
              </li>
              <li>INS = ‘0xA4’
              </li>
              <li>P1 =‘0x04’ (Select by DF name/application identifier)
              </li>
              <li>P2 = <code>p2</code> parameter if present, ‘0x00’
              otherwise (First or only occurrence).
              </li>
            </ul>
            <p>
              If <code>aid</code> is null, then no SELECT is sent, the channel
              is opened on the default selected <a>on-card</a> application. In
              the case of a UICC it is recommended that the API rejects the
              opening of the supplementary logical channel without a specific
              AID.
            </p>
            <p>
              This method will trigger the <a>Access Control Enforcer</a> to
              check the requesting <a>off-card</a> application is authorized to
              open such channel.
            </p>
            <p>
              For the SELECT command the API shall handle received status word
              as defined in <a href=
              "#general-rules-for-handling-of-status-word">section 7</a>,
              except that for T=0 protocol the GET RESPONSE shall also be sent
              in case of SW warning (‘62 XX’ or ‘63 XX’). If the status
              word for the SELECT command indicates that the SE was able to
              open a channel (status word ‘90 00’ or status words
              referencing a warning), the API shall keep the channel open and
              the channel's <code>openResponse</code> attribute shall return
              the status word for the SELECT command together with data, if any
              data is received.
            </p>
            <p>
              Other status words for the SELECT command which indicate that the
              SE was not able to open a channel shall be considered as an error
              and the corresponding channel shall not be opened.
            </p>
            <table class="parameters">
              <tbody>
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    aid
                  </td>
                  <td class="prmType">
                    <code>Uint8Array</code>
                  </td>
                  <td class="prmNullTrue">
                    <span role="img" aria-label="True">&#10004;</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">&#10008;</span>
                  </td>
                  <td class="prmDesc">
                    This parameter value MUST either be:
                    <ul>
                      <li>The complete <a>Application Identifier</a> of the
                      targeted <a>on-card</a> application;
                      </li>
                      <li>A partial <a>Application Identifier</a> matching a
                      set of targeted <a>on-card</a> applications. The
                      application with the first matching AID shall be
                      selected;
                      </li>
                      <li>
                        <code>null</code> if the implicitly selected
                        application on this channel shall be selected.
                      </li>
                    </ul>
                  </td>
                </tr>
                <tr>
                  <td class="prmName">
                    p2
                  </td>
                  <td class="prmType">
                    <code>octet</code>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">&#10008;</span>
                  </td>
                  <td class="prmOptTrue">
                    <span role="img" aria-label="True">&#10004;</span>
                  </td>
                  <td class="prmDesc">
                    The P2 parameter of the SELECT APDU executed for this
                    channel. Except for specific needs, it is recommended to
                    omit this method parameter. If provided, the following
                    values are supported as defined in [[!ISO7816-4]]:
                    ‘00’, ‘04’, ‘08’, ‘0C’.
                  </td>
                </tr>
              </tbody>
            </table>
          </dd>
          <dt>
            <dfn>close</dfn>
          </dt>
          <dd>
            This method closes the connection session to the Secure Element.
            This will close any channels opened through this session object.
            Invoking <code>close()</code> method on an already closed session
            has no effect. After invoking this method, calling any other method
            on this object MUST fail with an <a>SEClosedException</a> error.
          </dd>
        </dl>
      </section>
    </section><!-- Interface Session -->
    <!-- - - - - - - - - - - - Interface Channel - - - - - - - - - -->
    <section>
      <h2>
        <a>Channel</a> Interface
      </h2>
      <p>
        A <a>Channel</a> represents an [[!ISO7816-4]] channel opened to a
        Secure Element. It can be either a supplementary logical channel or the
        basic logical channel. It can be used to send commands to and receive
        responses from an <a>on-card</a> application.
      </p>
      <pre class='idl'>
interface Channel {
    readonly        attribute Session     session;
    readonly        attribute ChannelType channelType;
    readonly        attribute SEResponse? openResponse;
                    attribute int?        timeout;
    Promise&lt;SEResponse&gt; selectNext ();
    Promise&lt;SEResponse&gt; transmit (SECommand cmd);
    Promise&lt;Uint8Array&gt; transmitRaw (Uint8Array cmd);
    Promise&lt;void&gt;       close ();
};
</pre>
      <section>
        <h3>
          Attributes
        </h3>
        <dl data-link-for="Channel" data-dfn-for="Channel" class="attributes">
          <dt>
            <dfn>session</dfn> of type <span class=
            "idlAttrType"><a>Session</a></span>, readonly
          </dt>
          <dd>
            This attribute MUST return the session object from which this
            Channel object was created.
          </dd>
          <dt>
            <dfn>channelType</dfn> of type <span class=
            "idlAttrType"><a>ChannelType</a></span>, readonly
          </dt>
          <dd>
            This attribute MUST return this channel type.
          </dd>
          <dt>
            <dfn>openResponse</dfn> of type <span class=
            "idlAttrType"><a>SEResponse</a></span>, readonly, nullable
          </dt>
          <dd>
            This attribute MUST return the Secure Element's response to the
            channel opening operation. It MUST be <code>null</code> if the
            channel was opened on the default <a>on-card</a> application (no
            <a>AID</a> was provided in the open channel operation).
          </dd>
          <dt>
            <dfn>timeout</dfn> of type <span class=
            "idlAttrType"><a>int</a></span>
          </dt>
          <dd>
            The timeout in ms of commands sent through this channel. Any
            command sent through this channel is guaranteed to be aborted after
            <code>timeout</code> ms.
          </dd>
        </dl>
      </section>
      <section>
        <h3>
          Methods
        </h3>
        <dl data-link-for="Channel" data-dfn-for="Channel" class="methods">
          <dt>
            <dfn>selectNext</dfn>
          </dt>
          <dd>
            Updates the targeted <a>on-card</a> application of this channel to
            be the next one matching the partial <a>Application Identifier</a>
            passed when this channel was open. Invoking this method MUST fail
            with an <code>SEInvalidStateException</code> error if this channel
            was not open with a partial AID or with an
            <code>SENoApplicationException</code> error if there is no next
            application matching that partial AID. In that case the application
            associated to this channel is unchanged. If a next application has
            been found and associated to this channel, this operation succeeds
            and returns the Secure Element's response.
            <p>
              For the SELECT command the API shall handle received status word
              as defined in <a href=
              "#general-rules-for-handling-of-status-word">section 7</a>,
              except that for T=0 protocol the GET RESPONSE shall also be sent
              in case of SW warning (‘62 XX’ or ‘63 XX’). If the status
              word for the SELECT command indicates that the SE was able to
              open a channel (status word ‘90 00’ or status words
              referencing a warning), the API shall keep the channel open and
              the channel's <code>openResponse</code> attribute shall return
              the status word for the SELECT command together with data, if any
              data is received.
            </p>
          </dd>
          <dt>
            <dfn>transmit</dfn>
          </dt>
          <dd>
            <p>
              This method transmits a command to the Secure Element. The user
              agent MUST ensure the synchronisation between all the concurrent
              calls to this method: a command MUST NOT be sent to a Secure
              Element while a response is still pending on any channel from
              this same Secure Element.
            </p>
            <p>
              This method will trigger the <a>Access Control Enforcer</a> to
              check the requesting <a>off-card</a> application is authorized to
              send such command on this channel.
            </p>
            <p>
              The channel information in the <a>class byte</a> in the <a>APDU
              command</a> will be ignored. The system MAY modify the <a>class
              byte</a> of the command to ensure the APDU is transported on this
              channel. To ensure the invoking web application does not exit
              from the scope of this channel, the user agent MUST reject the
              following commands with <code>SEInvalidValueException</code>
              error value:
            </p>
            <ul>
              <li>MANAGE_CHANNEL (INS=0x70)
              </li>
              <li>SELECT by DF Name (INS=0xA4 and P1=04)
              </li>
            </ul>
            <table class="parameters">
              <tbody>
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    cmd
                  </td>
                  <td class="prmType">
                    <code>SECommand</code>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">&#10008;</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">&#10008;</span>
                  </td>
                  <td class="prmDesc">
                    The command to send to the <a>on-card</a> application.
                  </td>
                </tr>
              </tbody>
            </table>
          </dd>
          <dt>
            <dfn>transmitRaw</dfn>
          </dt>
          <dd>
            <p>
              This method behaves exactly as the <a>transmit</a> method above,
              except that both its parameter and the response are passed as a
              raw binary data. Before transmitting the command to the Secure
              Element, the implementation of this method MUST set the logical
              channel in the <a>class byte</a> of the command so that it fits
              the channel allocated to this <a>Channel</a> object.
            </p>
            <p>
              This method will trigger the <a>Access Control Enforcer</a> to
              check the requesting <a>off-card</a> application is authorized to
              send such command on this channel.
            </p>
            <table class="parameters">
              <tbody>
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    cmd
                  </td>
                  <td class="prmType">
                    <code>Uint8Array</code>
                  </td>
                  <td class="prmNullFalse">
                    <span role="img" aria-label="False">&#10008;</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">&#10008;</span>
                  </td>
                  <td class="prmDesc">
                    The raw command to send to the <a>on-card</a> application.
                    The channel information in the <a>class byte</a> of the
                    command (first octet of the cmd data) will be ignored.
                  </td>
                </tr>
              </tbody>
            </table>
          </dd>
          <dt>
            <dfn>close</dfn>
          </dt>
          <dd>
            Closes this channel object. If the method is called when the
            channel is already closed, this method MUST be ignored. The
            <code>close()</code> method MUST wait for completion of any pending
            <code>transmit()</code> operation before closing the channel.
            <p>
              If the channel is not the basic channel, then a MANAGE CHANNEL
              Close (P1=0x80) command shall be sent to the Secure Element for
              closing the channel.
            </p>
            <p>
              If the channel is the basic channel, then the following procedure
              MUST be followed for closing the channel:
            </p>
            <ol>
              <li>Send a MANAGE CHANNEL Reset (P1=0x40) command, as defined by
              [[ISO7816-4]].
              </li>
              <li>If previous command is not supported by the card (i.e. card
              returns an error SW), then SELECT by DF Name (P1=0x04; P2=0x00)
              command shall be sent with an empty AID (Lc=0x00). All data
              returned for the SELECT by DF Name command shall be discarded.
              </li>
            </ol>
            <p>
              In all cases the last SW of the MANAGE CHANNEL Close, MANAGE
              CHANNEL Reset, or SELECT by DF Name command shall be ignored and
              the channel object shall be closed by the API. After invoking
              this method, calling any other method on this channel object MUST
              then fail with an <a>SEClosedException</a> error.
            </p>
          </dd>
        </dl>
      </section>
      <!-- - - - - - - - - - - - Enum ChannelType - - - - - - - - - -->
      <section>
        <h3>
          <a>ChannelType</a> Enum
        </h3>
        <p>
          The <a>ChannelType</a> enum identifies the type of the Secure Element
          channel.
        </p>
        <pre class="idl">
enum ChannelType {
  "basic",
  "supplementary"
};
            
</pre>
        <table data-link-for="ChannelType" data-dfn-for="ChannelType" class=
        "simple">
          <tbody>
            <tr>
              <th colspan="2">
                Enumeration description
              </th>
            </tr>
            <tr>
              <td>
                <dfn>basic</dfn>
              </td>
              <td>
                <p>
                  Basic logical channel, as defined in [[!ISO7816-4]] (channel
                  number 0).
                </p>
              </td>
            </tr>
            <tr>
              <td>
                <dfn>supplementary</dfn>
              </td>
              <td>
                <p>
                  Supplementary logical channel, as defined in [[!GP]] (channel
                  number &gt; 0).
                </p>
              </td>
            </tr>
          </tbody>
        </table>
      </section><!-- Enum ChannelType -->
    </section><!-- Interface Channel -->
    <!-- - - - - - - - - - - - Interface SECommand - - - - - - - - - -->
    <section>
      <h2>
        <a>SECommand</a> Interface
      </h2>
      <p>
        The <a>SECommand</a> interface represents an <a>APDU command</a> that
        can be sent to a Secure Element.
      </p>
      <pre class="idl">
[Constructor(octet cla, octet ins, octet p1, octet p2, optional Uint8Array data, optional octet le, optional boolean isExtended)]
interface SECommand {
    attribute octet          cla;
    attribute octet          ins;
    attribute octet          p1;
    attribute octet          p2;
    attribute Uint8Array?    data;
    attribute unsigned short le;
    attribute boolean        isExtended;
};
</pre>
      <section>
        <h3>
          Attributes
        </h3>
        <dl data-link-for="SECommand" data-dfn-for="SECommand" class=
        "attributes">
          <dt>
            <dfn>cla</dfn> of type <span class=
            "idlAttrType"><a>octet</a></span>
          </dt>
          <dd>
            <a>Class byte</a>.
          </dd>
          <dt>
            <dfn>ins</dfn> of type <span class=
            "idlAttrType"><a>octet</a></span>
          </dt>
          <dd>
            <a>Instruction byte</a>.
          </dd>
          <dt>
            <dfn>p1</dfn> of type <span class="idlAttrType"><a>octet</a></span>
          </dt>
          <dd>
            First octet of the <a>parameter bytes</a>.
          </dd>
          <dt>
            <dfn>p2</dfn> of type <span class="idlAttrType"><a>octet</a></span>
          </dt>
          <dd>
            Second octet of the <a>parameter bytes</a>.
          </dd>
          <dt>
            <dfn>data</dfn> of type <span class=
            "idlAttrType"><a>Uint8Array</a></span>, nullable
          </dt>
          <dd>
            <a>Data field bytes</a> or <code>null</code> if command has no
            data.
          </dd>
          <dt>
            <dfn>le</dfn> of type <span class="idlAttrType"><a>unsigned
            short</a></span>
          </dt>
          <dd>
            The length of the expected response data or <code>undefined</code>
            if application does not require a specific length.
          </dd>
          <dt>
            <dfn>isExtended</dfn> of type <span class=
            "idlAttrType"><a>boolean</a></span>
          </dt>
          <dd>
            If set to <code>true</code> the command will be transmitted using
            <a>extended length</a> encoding.
          </dd>
        </dl>
      </section>
    </section><!-- Interface SECommand -->
    <!-- - - - - - - - - - - - Interface SEResponse - - - - - - - - - -->
    <section>
      <h2>
        <a>SEResponse</a> Interface
      </h2>
      <p>
        The <a>SEResponse</a> interface represents an <a>APDU response</a>
        received from a Secure Element.
      </p>
      <pre class="idl">
[Constructor(Uint8Array raw)]
interface SEResponse {
    readonly        attribute Channel    channel;
    readonly        attribute octet      sw1;
    readonly        attribute octet      sw2;
    readonly        attribute Uint8Array data;
    boolean isStatus (octet? sw1, octet? sw2);
};
</pre>
      <section>
        <h3>
          Attributes
        </h3>
        <dl data-link-for="SEResponse" data-dfn-for="SEResponse" class=
        "attributes">
          <dt>
            <dfn>channel</dfn> of type <span class=
            "idlAttrType"><a>Channel</a></span>, readonly
          </dt>
          <dd>
            This attribute MUST return the channel object that was used to
            transmit the command which triggered this response object.
          </dd>
          <dt>
            <dfn>sw1</dfn> of type <span class=
            "idlAttrType"><a>octet</a></span>, readonly
          </dt>
          <dd>
            First octet of response's <a>status word</a>
          </dd>
          <dt>
            <dfn>sw2</dfn> of type <span class=
            "idlAttrType"><a>octet</a></span>, readonly
          </dt>
          <dd>
            Second octet of response's <a>status word</a>
          </dd>
          <dt>
            <dfn>data</dfn> of type <span class=
            "idlAttrType"><a>Uint8Array</a></span>, readonly
          </dt>
          <dd>
            The response's <a>data field bytes</a>
          </dd>
        </dl>
      </section>
      <section>
        <h3>
          Methods
        </h3>
        <dl data-link-for="SEResponse" data-dfn-for="SEResponse" class=
        "methods">
          <dt>
            <dfn>isStatus</dfn>
          </dt>
          <dd>
            Utility method to test the <a>status word</a> of an <a>APDU
            response</a>. This method MUST return <code>true</code> if the
            parameters match the value of the response.
            <table class="parameters">
              <tbody>
                <tr>
                  <th>
                    Parameter
                  </th>
                  <th>
                    Type
                  </th>
                  <th>
                    Nullable
                  </th>
                  <th>
                    Optional
                  </th>
                  <th>
                    Description
                  </th>
                </tr>
                <tr>
                  <td class="prmName">
                    sw1
                  </td>
                  <td class="prmType">
                    <code>octet</code>
                  </td>
                  <td class="prmNullTrue">
                    <span role="img" aria-label="True">&#10004;</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">&#10008;</span>
                  </td>
                  <td class="prmDesc">
                    Value to compare to the first octet of response's <a>status
                    word</a> or <code>null</code> if this first octet may have
                    any value.
                  </td>
                </tr>
                <tr>
                  <td class="prmName">
                    sw2
                  </td>
                  <td class="prmType">
                    <code>octet</code>
                  </td>
                  <td class="prmNullTrue">
                    <span role="img" aria-label="True">&#10004;</span>
                  </td>
                  <td class="prmOptFalse">
                    <span role="img" aria-label="False">&#10008;</span>
                  </td>
                  <td class="prmDesc">
                    Value to compare to the second octet of response's
                    <a>status word</a> or <code>null</code> if this second
                    octet may have any value.
                  </td>
                </tr>
              </tbody>
            </table>
          </dd>
        </dl>
      </section>
    </section><!-- Interface SEResponse -->
    <!-- - - - - - - - - - - - - -  Errors - - - - - - - - - - - - - - - - -->
    <section>
      <h2>
        Error Types
      </h2>
      <p>
        In the interfaces defined above, some methods return a <a>Promise</a>
        object. If an error occurs during the execution of any of these
        methods, the <code>reject()</code> method of Promise's resolver will be
        invoked with an error value of one of the following <a>DOMException</a>
        subtypes:
      </p>
      <dl title="errors">
        <dt>
          SESecurityException
        </dt>
        <dd>
          The requested operation does not match the Secure Element access
          conditions, as defined in <a href="#access-control">Access
          Control</a> section
        </dd>
        <dt>
          SEIoException
        </dt>
        <dd>
          Communication error
        </dd>
        <dt>
          SEInvalidStateException
        </dt>
        <dd>
          The target object was not in the proper state to execute the
          operation
        </dd>
        <dt>
          SEInvalidValueException
        </dt>
        <dd>
          The method was invoked with an incorrect parameter value
        </dd>
        <dt>
          SENoChannelException
        </dt>
        <dd>
          The channel could not be opened because no channel is available
        </dd>
        <dt>
          SENoApplicationException
        </dt>
        <dd>
          The requested <a>on-card</a> application was not found on the Secure
          Element
        </dd>
        <dt>
          SEClosedException
        </dt>
        <dd>
          The operation could not be fulfilled because the target object is
          closed
        </dd>
        <dt>
          SEUnsupportedException
        </dt>
        <dd>
          The operation is not supported by the reader or Secure Element.
        </dd>
        <dt>
          SEUnknownException
        </dt>
        <dd>
          Internal error, no further details available
        </dd>
      </dl>
    </section><!-- Errors -->
    <!-- - - - - - - - - - - - - -  Examples  - - - - - - - - - - - - - - - - -->
    <section>
      <h2>
        Code Example
      </h2>
      <p>
        The javascript code excerpt below shows how a web application can wait
        for a card to be present and send it an APDU command:
      </p>
      <pre class="example highlight">

            // my application identifier
            var myAppId = ...;
            // my application command
            var myAppCmd = new SECommand(...);

            // get Secure Element manager
            var seMgr = navigator.secureElementManager;

            // register sepresent event handler
            seMgr.onsepresent = function(event) {

              // open session
              event.reader.openSession()
              .then(

                function (session) {
                  // open a basic logical channel to my application
                  return session.openBasicChannel(myAppID);
                }

              ).then(

                function (channel) {
                  // send APDU to my application
                  return channel.transmit(myAppCmd);
                }

              ).then(

                function (response) {
                  if (!response.isStatus(0x90, 0x00) {
                    // this might be an error
                    // ...
                  }
                  response.channel.session.reader.close();
                }

              );
            };

</pre>
      <p>
        For simplicity and readability reasons, the code above omits the error
        handling that would have to be implemented in a real application.
      </p>
    </section><!-- Examples -->
    <!-- - - - - - - - - - - - - -  Changes - - - - - - - - - - - - - - - - -->
    <section class="appendix" id="Changes">
      <h2>
        Changes
      </h2>
      <p>
        The complete list of changes can be viewed on <a href=
        "https://github.com/GlobalPlatform/WebApis-for-SE/commits/gh-pages">Github</a>.
        You can also check the <a href=
        "https://github.com/GlobalPlatform/WebApis-for-SE/issues">issues</a>.
      </p>
    </section>
  </body>
</html>
